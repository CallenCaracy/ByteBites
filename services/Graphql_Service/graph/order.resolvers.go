package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"Graphql_Service/graph/model"
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*model.Order, error) {
	if r.DB5 == nil {
		return nil, fmt.Errorf("database connection not initialized")
	}

	if err := r.DB5.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("database connection error: %v", err)
	}

	tx, err := r.DB5.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback()

	orderID := uuid.New()
	createdAt := time.Now()

	// Insert order
	orderQuery := `
        INSERT INTO orders (id, user_id, total_price, order_status, order_type, delivery_address, special_requests, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    `
	_, err = tx.ExecContext(ctx, orderQuery,
		orderID, input.UserID, input.TotalPrice, input.OrderStatus, input.OrderType,
		input.DeliveryAddress, input.SpecialRequests, createdAt)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %v", err)
	}

	// Insert order items
	for _, item := range input.Items {
		itemID := uuid.New()
		_, err := tx.ExecContext(ctx, `
            INSERT INTO order_items (id, order_id, menu_item_id, quantity, price, customizations, created_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
        `, itemID, orderID, item.MenuItemID, item.Quantity, item.Price, item.Customizations, createdAt)
		if err != nil {
			return nil, fmt.Errorf("failed to create order item: %v", err)
		}
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return &model.Order{
		ID:              orderID,
		UserID:          input.UserID,
		TotalPrice:      input.TotalPrice,
		OrderStatus:     *input.OrderStatus,
		OrderType:       input.OrderType,
		DeliveryAddress: input.DeliveryAddress,
		SpecialRequests: input.SpecialRequests,
		CreatedAt:       &createdAt,
	}, nil
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, input model.UpdateOrderInput) (*model.Order, error) {
	if r.DB5 == nil {
		return nil, fmt.Errorf("database connection not initialized")
	}

	if err := r.DB5.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("database connection error: %v", err)
	}

	tx, err := r.DB5.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback()

	updatedAt := time.Now()

	query := `
        UPDATE orders
        SET total_price = $1, order_status = $2, order_type = $3,
            delivery_address = $4, special_requests = $5, updated_at = $6
        WHERE id = $7
        RETURNING id, user_id, total_price, order_status, order_type, delivery_address, special_requests, created_at
    `

	row := tx.QueryRowContext(ctx, query, input.TotalPrice, input.OrderStatus, input.OrderType,
		input.DeliveryAddress, input.SpecialRequests, updatedAt, input.ID)

	var o model.Order
	err = row.Scan(&o.ID, &o.UserID, &o.TotalPrice, &o.OrderStatus, &o.OrderType,
		&o.DeliveryAddress, &o.SpecialRequests, &o.CreatedAt)
	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("order not found")
	}
	if err != nil {
		return nil, err
	}

	if err := tx.Commit(); err != nil {
		return nil, err
	}

	o.UpdatedAt = &updatedAt
	return &o, nil
}

// DeleteOrder is the resolver for the deleteOrder field.
func (r *mutationResolver) DeleteOrder(ctx context.Context, id uuid.UUID) (bool, error) {
	if r.DB5 == nil {
		return false, fmt.Errorf("database connection not initialized")
	}

	if err := r.DB5.PingContext(ctx); err != nil {
		return false, fmt.Errorf("database connection error: %v", err)
	}

	tx, err := r.DB5.BeginTx(ctx, nil)
	if err != nil {
		return false, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer tx.Rollback()

	// First delete order items
	_, err = tx.ExecContext(ctx, `DELETE FROM order_items WHERE order_id = $1`, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete order items: %v", err)
	}

	// Then delete the order
	res, err := tx.ExecContext(ctx, `DELETE FROM orders WHERE id = $1`, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete order: %v", err)
	}

	if err := tx.Commit(); err != nil {
		return false, fmt.Errorf("failed to commit transaction: %v", err)
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return false, fmt.Errorf("failed to get rows affected: %v", err)
	}

	return rowsAffected > 0, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id uuid.UUID) (*model.Order, error) {
	if r.DB5 == nil {
		return nil, fmt.Errorf("database connection not initialized")
	}

	if err := r.DB5.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("database connection error: %v", err)
	}

	query := `
		SELECT id, user_id, total_price, order_status, order_type, delivery_address, special_requests, created_at, updated_at
		FROM orders
		WHERE id = $1
	`

	row := r.DB5.QueryRowContext(ctx, query, id)
	var o model.Order
	err := row.Scan(&o.ID, &o.UserID, &o.TotalPrice, &o.OrderStatus, &o.OrderType,
		&o.DeliveryAddress, &o.SpecialRequests, &o.CreatedAt, &o.UpdatedAt)
	if err != nil {
		return nil, err
	}

	return &o, nil
}

// OrdersByUser is the resolver for the ordersByUser field.
func (r *queryResolver) OrdersByUser(ctx context.Context, userID uuid.UUID) ([]*model.Order, error) {
	if r.DB5 == nil {
		return nil, fmt.Errorf("database connection not initialized")
	}

	if err := r.DB5.PingContext(ctx); err != nil {
		return nil, fmt.Errorf("database connection error: %v", err)
	}

	query := `
		SELECT id, user_id, total_price, order_status, order_type, delivery_address, special_requests, created_at, updated_at
		FROM orders
		WHERE user_id = $1
		ORDER BY created_at DESC
	`

	rows, err := r.DB5.QueryContext(ctx, query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// Pre-allocate the slice with initial capacity
	var orders []*model.Order

	for rows.Next() {
		var o model.Order
		err := rows.Scan(&o.ID, &o.UserID, &o.TotalPrice, &o.OrderStatus, &o.OrderType,
			&o.DeliveryAddress, &o.SpecialRequests, &o.CreatedAt, &o.UpdatedAt)
		if err != nil {
			return nil, err
		}
		orders = append(orders, &o)
	}

	return orders, nil
}

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
