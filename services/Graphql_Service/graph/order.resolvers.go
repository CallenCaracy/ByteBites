package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"Graphql_Service/graph/model"
	service "Graphql_Service/grpc_clients"
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/CallenCaracy/ByteBites/services/Kitchen_Service/pb"
)

// CreateCart is the resolver for the createCart field.
func (r *mutationResolver) CreateCart(ctx context.Context, userID string) (*model.Cart, error) {
	var cartID string

	query := `
        INSERT INTO carts (user_id, created_at, updated_at)
        VALUES ($1, NOW(), NOW())
        RETURNING id
    `

	err := r.DB5.QueryRow(query, userID).Scan(&cartID)
	if err != nil {
		return nil, fmt.Errorf("failed to create cart: %v", err)
	}

	cart := &model.Cart{
		ID:        cartID,
		UserID:    userID,
		CreatedAt: time.Now().Format(time.RFC3339),
		UpdatedAt: func() *string { t := time.Now().Format(time.RFC3339); return &t }(),
	}

	return cart, nil
}

// ClearCart is the resolver for the clearCart field.
func (r *mutationResolver) ClearCart(ctx context.Context, cartID string) (bool, error) {
	query := `DELETE FROM cart_items WHERE cart_id = $1`

	cmdTag, err := r.DB5.Exec(query, cartID)
	if err != nil {
		return false, fmt.Errorf("failed to clear cart: %v", err)
	}

	rowsAffected, err := cmdTag.RowsAffected()
	if err != nil {
		return false, fmt.Errorf("failed to get rows affected: %v", err)
	}
	if rowsAffected == 0 {
		log.Printf("No items to clear in cart %s\n", cartID)
	}

	return true, nil
}

// AddCartItem is the resolver for the addCartItem field.
func (r *mutationResolver) AddCartItem(ctx context.Context, input model.AddCartItemInput) (*model.CartItem, error) {
	tx, err := r.DB5.Begin()
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %v", err)
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		} else {
			_ = tx.Commit()
		}
	}()

	var cartID string
	queryCheck := `SELECT id FROM carts WHERE user_id = $1 LIMIT 1`

	err = tx.QueryRow(queryCheck, input.UserID).Scan(&cartID)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			queryCreate := `
				INSERT INTO carts (user_id, created_at, updated_at)
				VALUES ($1, NOW(), NOW())
				RETURNING id
			`
			err = tx.QueryRow(queryCreate, input.UserID).Scan(&cartID)
			if err != nil {
				return nil, fmt.Errorf("failed to create cart in tx: %v", err)
			}
		} else {
			return nil, fmt.Errorf("failed to find existing cart: %v", err)
		}
	}

	var cartItemID string
	queryInsertItem := `
        INSERT INTO cart_items (cart_id, menu_item_id, quantity, price, customizations, created_at)
        VALUES ($1, $2, $3, $4, $5, NOW())
        RETURNING id
    `
	err = tx.QueryRow(queryInsertItem,
		cartID,
		input.MenuItemID,
		input.Quantity,
		input.Price,
		input.Customizations,
	).Scan(&cartItemID)
	if err != nil {
		return nil, fmt.Errorf("failed to add cart item: %v", err)
	}

	cartItem := &model.CartItem{
		ID:             cartItemID,
		CartID:         cartID,
		MenuItemID:     input.MenuItemID,
		Quantity:       input.Quantity,
		Price:          input.Price,
		Customizations: input.Customizations,
		CreatedAt:      time.Now().Format(time.RFC3339),
	}

	return cartItem, nil
}

// UpdateCartItem is the resolver for the updateCartItem field.
func (r *mutationResolver) UpdateCartItem(ctx context.Context, input model.UpdateCartItemInput) (*model.CartItem, error) {
	if input.Quantity == nil {
		return nil, errors.New("quantity must be provided")
	}

	resp, err := service.KitchenClient.CheckStock(ctx, &pb.CheckStockRequest{
		MenuItemId: input.MenuItemID,
		Quantity:   *input.Quantity,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to check inventory: %w", err)
	}
	if !resp.Available || resp.AvailableQuantity < int32(*input.Quantity) {
		return nil, fmt.Errorf("not enough stock for menu item %s, available: %d, requested: %d",
			input.ID, resp.AvailableQuantity, *input.Quantity)
	}

	var cartItem model.CartItem
	err = r.DB5.QueryRowContext(ctx, `
		SELECT id, cart_id, menu_item_id, quantity, price, customizations, created_at, updated_at
		FROM cart_items
		WHERE id = $1
	`, input.ID).Scan(
		&cartItem.ID, &cartItem.CartID, &cartItem.MenuItemID,
		&cartItem.Quantity, &cartItem.Price, &cartItem.Customizations,
		&cartItem.CreatedAt, &cartItem.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("cart item not found: %w", err)
	}

	cartItem.Quantity = *input.Quantity
	if input.Customizations != nil {
		cartItem.Customizations = input.Customizations
	}

	err = r.DB5.QueryRowContext(ctx, `
		UPDATE cart_items
		SET quantity = $1, customizations = $2, updated_at = NOW()
		WHERE id = $3
		RETURNING id, cart_id, menu_item_id, quantity, price, customizations, created_at, updated_at
	`, cartItem.Quantity, cartItem.Customizations, cartItem.ID).Scan(
		&cartItem.ID, &cartItem.CartID, &cartItem.MenuItemID,
		&cartItem.Quantity, &cartItem.Price, &cartItem.Customizations,
		&cartItem.CreatedAt, &cartItem.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("error updating cart item: %w", err)
	}

	return &cartItem, nil
}

// RemoveCartItem is the resolver for the removeCartItem field.
func (r *mutationResolver) RemoveCartItem(ctx context.Context, id string) (bool, error) {
	query := `DELETE FROM cart_items WHERE id = $1`
	cmdTag, err := r.DB5.Exec(query, id)
	if err != nil {
		return false, fmt.Errorf("failed to remove cart item: %v", err)
	}

	rowsAffected, err := cmdTag.RowsAffected()
	if err != nil {
		return false, fmt.Errorf("failed to get rows affected: %v", err)
	}
	if rowsAffected == 0 {
		return false, nil
	}

	return true, nil
}

// CreateOrderFromCart is the resolver for the createOrderFromCart field.
func (r *mutationResolver) CreateOrderFromCart(ctx context.Context, cartID string, userID string, orderType string, deliveryAddress *string, specialRequests *string) (*model.Order, error) {
	tx, err := r.DB5.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}

	committed := false
	defer func() {
		if !committed {
			_ = tx.Rollback() // ignore rollback error
		}
	}()

	// Step 1: Get cart items
	rows, err := tx.QueryContext(ctx, `SELECT menu_item_id, quantity, price, customizations FROM cart_items WHERE cart_id = $1`, cartID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch cart items: %w", err)
	}
	defer rows.Close()

	var items []struct {
		MenuItemID     string
		Quantity       int
		Price          float64
		Customizations *string
	}
	var totalPrice float64

	for rows.Next() {
		var item struct {
			MenuItemID     string
			Quantity       int
			Price          float64
			Customizations *string
		}
		if err := rows.Scan(&item.MenuItemID, &item.Quantity, &item.Price, &item.Customizations); err != nil {
			return nil, fmt.Errorf("failed to scan cart item: %w", err)
		}

		// Check stock AFTER scanning values
		resp, err := service.KitchenClient.CheckStock(ctx, &pb.CheckStockRequest{
			MenuItemId: item.MenuItemID,
			Quantity:   int32(item.Quantity),
		})
		if err != nil {
			return nil, fmt.Errorf("failed to check inventory for item %s: %w", item.MenuItemID, err)
		}
		if !resp.Available || resp.AvailableQuantity < int32(item.Quantity) {
			return nil, fmt.Errorf("not enough stock for menu item %s, available: %d, requested: %d",
				item.MenuItemID, resp.AvailableQuantity, item.Quantity)
		}

		items = append(items, item)
		totalPrice += item.Price * float64(item.Quantity)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error reading cart items: %w", err)
	}

	if len(items) == 0 {
		return nil, fmt.Errorf("cart is empty")
	}

	// Step 2: Create the order
	var orderID string
	err = tx.QueryRowContext(ctx, `
		INSERT INTO orders (user_id, total_price, order_status, order_type, delivery_address, special_requests)
		VALUES ($1, $2, 'pending', $3, $4, $5)
		RETURNING id
	`, userID, totalPrice, orderType, deliveryAddress, specialRequests).Scan(&orderID)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %w", err)
	}

	// Step 3: Insert order items
	for _, item := range items {
		_, err := tx.ExecContext(ctx, `
			INSERT INTO order_items (order_id, menu_item_id, quantity, price, customizations)
			VALUES ($1, $2, $3, $4, $5)
		`, orderID, item.MenuItemID, item.Quantity, item.Price, item.Customizations)
		if err != nil {
			return nil, fmt.Errorf("failed to insert order item: %w", err)
		}
	}

	// Step 4: Clear the cart
	_, err = tx.ExecContext(ctx, `DELETE FROM cart_items WHERE cart_id = $1`, cartID)
	if err != nil {
		return nil, fmt.Errorf("failed to clear cart: %w", err)
	}

	// Step 5: Commit
	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}
	committed = true

	// Step 6: Return order
	return &model.Order{
		ID:              orderID,
		UserID:          userID,
		TotalPrice:      totalPrice,
		OrderStatus:     "pending",
		OrderType:       &orderType,
		DeliveryAddress: deliveryAddress,
		SpecialRequests: specialRequests,
		// Timestamps could be populated here if needed
	}, nil
}

// UpdateOrderStatus implements MutationResolver.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, orderStatus string) (*model.Order, error) {
	panic("unimplemented")
}

// GetCart is the resolver for the getCart field.
func (r *queryResolver) GetCart(ctx context.Context, userID string) (*model.Cart, error) {
	query := `SELECT id, user_id, created_at, updated_at FROM carts WHERE user_id = $1 LIMIT 1`
	row := r.DB5.QueryRow(query, userID)

	var cart model.Cart
	err := row.Scan(
		&cart.ID,
		&cart.UserID,
		&cart.CreatedAt,
		&cart.UpdatedAt,
	)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil // No cart exists for user
		}
		return nil, fmt.Errorf("failed to get cart: %v", err)
	}

	return &cart, nil
}

// GetCartItemsByCartID is the resolver for the getCartItemsByCartId field.
func (r *queryResolver) GetCartItemsByCartID(ctx context.Context, cartID string) ([]*model.CartItem, error) {
	query := `
		SELECT id, cart_id, menu_item_id, quantity, price, customizations, created_at, updated_at
		FROM cart_items
		WHERE cart_id = $1
	`
	rows, err := r.DB5.Query(query, cartID)
	if err != nil {
		return nil, fmt.Errorf("failed to get cart items: %v", err)
	}
	defer rows.Close()

	var items []*model.CartItem
	for rows.Next() {
		var item model.CartItem
		err := rows.Scan(
			&item.ID,
			&item.CartID,
			&item.MenuItemID,
			&item.Quantity,
			&item.Price,
			&item.Customizations,
			&item.CreatedAt,
			&item.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan cart item: %v", err)
		}
		items = append(items, &item)
	}

	if err = rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating cart items: %v", err)
	}

	return items, nil
}

// GetUserOrders is the resolver for the getUserOrders field.
func (r *queryResolver) GetUserOrders(ctx context.Context, userID string) ([]*model.Order, error) {
	// Step 1: Get orders for the user
	rows, err := r.DB5.QueryContext(ctx, `
		SELECT id, user_id, total_price, order_status, order_type, delivery_address, special_requests, created_at, updated_at
		FROM orders
		WHERE user_id = $1
		ORDER BY created_at DESC
	`, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch orders: %w", err)
	}
	defer rows.Close()

	var orders []*model.Order

	// Step 2: Iterate over orders and fetch corresponding items for each order
	for rows.Next() {
		var order model.Order
		err := rows.Scan(&order.ID, &order.UserID, &order.TotalPrice, &order.OrderStatus, &order.OrderType, &order.DeliveryAddress, &order.SpecialRequests, &order.CreatedAt, &order.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("failed to scan order: %w", err)
		}

		// Step 3: Get order items for the current order
		itemRows, err := r.DB5.QueryContext(ctx, `
			SELECT id, order_id, menu_item_id, quantity, price, customizations, created_at
			FROM order_items
			WHERE order_id = $1
			ORDER BY created_at DESC
		`, order.ID)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch order items: %w", err)
		}
		defer itemRows.Close()

		var orderItems []*model.OrderItem
		for itemRows.Next() {
			var item model.OrderItem
			err := itemRows.Scan(&item.ID, &item.OrderID, &item.MenuItemID, &item.Quantity, &item.Price, &item.Customizations, &item.CreatedAt)
			if err != nil {
				return nil, fmt.Errorf("failed to scan order item: %w", err)
			}
			orderItems = append(orderItems, &item)
		}

		if err := itemRows.Err(); err != nil {
			return nil, fmt.Errorf("error with order items rows: %w", err)
		}

		order.Items = orderItems
		orders = append(orders, &order)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error with orders rows: %w", err)
	}

	return orders, nil
}

// GetCartAndMenuItems is the resolver for the getCartAndMenuItems field.
func (r *queryResolver) GetCartAndMenuItems(ctx context.Context, userID string) (*model.CartWithMenu, error) {
	cartQuery := `SELECT id, user_id, created_at, updated_at FROM carts WHERE user_id = $1`
	var cart model.CartWithMenu
	err := r.DB5.QueryRow(cartQuery, userID).Scan(&cart.ID, &cart.UserID, &cart.CreatedAt, &cart.UpdatedAt)
	if err != nil {
		return nil, err
	}

	cartItemsQuery := `SELECT id, cart_id, menu_item_id, quantity, price, customizations, created_at, updated_at FROM cart_items WHERE cart_id = $1`
	rows, err := r.DB5.Query(cartItemsQuery, cart.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var cartItems []*model.CartItemWithMenuItem
	for rows.Next() {
		var cartItem model.CartItemWithMenuItem
		err := rows.Scan(&cartItem.ID, &cartItem.CartID, &cartItem.MenuItemID, &cartItem.Quantity, &cartItem.Price, &cartItem.Customizations, &cartItem.CreatedAt, &cartItem.UpdatedAt)
		if err != nil {
			return nil, err
		}

		menuItem, err := r.GetMenuItemByID(ctx, cartItem.MenuItemID)
		if err != nil {
			return nil, err
		}

		cartItem.MenuItem = &model.MenuItemForCart{
			ID:          menuItem.ID,
			Name:        menuItem.Name,
			Description: *menuItem.Description,
			Price:       menuItem.Price,
			ImageURL:    menuItem.ImageURL,
		}
		cartItems = append(cartItems, &cartItem)
	}

	cartResponse := &model.Cart{
		ID:        cart.ID,
		UserID:    cart.UserID,
		CreatedAt: cart.CreatedAt,
		UpdatedAt: cart.UpdatedAt,
		Items:     []*model.CartItem{},
	}

	for _, cartItemWithMenu := range cartItems {
		cartResponse.Items = append(cartResponse.Items, &model.CartItem{
			ID:             cartItemWithMenu.ID,
			CartID:         cartItemWithMenu.CartID,
			MenuItemID:     cartItemWithMenu.MenuItemID,
			Quantity:       cartItemWithMenu.Quantity,
			Price:          cartItemWithMenu.Price,
			Customizations: cartItemWithMenu.Customizations,
			CreatedAt:      cartItemWithMenu.CreatedAt,
			UpdatedAt:      cartItemWithMenu.UpdatedAt,
		})
	}

	return &model.CartWithMenu{
		ID:        cartResponse.ID,
		UserID:    cartResponse.UserID,
		CreatedAt: cartResponse.CreatedAt,
		UpdatedAt: cartResponse.UpdatedAt,
		Items:     cartItems,
	}, nil
}

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
