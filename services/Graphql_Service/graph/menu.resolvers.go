package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"Graphql_Service/graph/model"
	service "Graphql_Service/grpc_clients"
	"context"
	"fmt"

	"github.com/CallenCaracy/ByteBites/services/Menu_Service/pb"
	"github.com/google/uuid"
	"github.com/lib/pq"
)

// CreateMenuItem - Insert a new menu item
func (r *mutationResolver) CreateMenuItem(ctx context.Context, input model.NewMenuItem) (*model.MenuItemFull, error) {
	var discountedPrice float32
	if input.Discount > 0 {
		resp, err := service.MenuClient.CalculateDiscount(ctx, &pb.DiscountRequest{Price: float32(input.Price), Discount: float32(input.Discount)})
		if err != nil {
			return nil, fmt.Errorf("failed to calculate discounted price: %v", err)

		}
		discountedPrice = resp.DiscountedPrice
	} else {
		discountedPrice = float32(input.Price)
	}

	query := `INSERT INTO public.menu_list (
		name, description, price, category, discount, discounted_price,
		availability_status, image_url, created_at, updated_at
	) VALUES (
		$1, $2, $3, $4, $5, $6,
		$7, $8, NOW(), NOW()
	)
	RETURNING id, name, description, price, category, discount, discounted_price,
		availability_status, image_url, created_at, updated_at`

	item := &model.MenuItem{
		Name:               input.Name,
		Description:        input.Description,
		Price:              input.Price,
		Category:           input.Category,
		Discount:           input.Discount,
		AvailabilityStatus: input.AvailabilityStatus,
		ImageURL:           input.ImageURL,
	}

	err := r.Resolver.DB2.QueryRow(query,
		item.Name, item.Description, item.Price, item.Category,
		item.Discount, discountedPrice,
		item.AvailabilityStatus, item.ImageURL,
	).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price, &item.Category,
		&item.Discount, &discountedPrice,
		&item.AvailabilityStatus, &item.ImageURL,
		&item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	r.Resolver.mu.Lock()
	for id, ch := range r.Resolver.MenuItemCreatedObservers {
		select {
		case ch <- &model.MenuItemFull{
			ID:                 item.ID,
			Name:               item.Name,
			Description:        item.Description,
			Price:              item.Price,
			Category:           item.Category,
			Discount:           item.Discount,
			DiscountedPrice:    float64(discountedPrice),
			AvailabilityStatus: item.AvailabilityStatus,
			ImageURL:           item.ImageURL,
			CreatedAt:          item.CreatedAt,
			UpdatedAt:          item.UpdatedAt,
		}:
			// Sent successfully
		default:
			// Channel likely dead or slow reader â€” clean up
			close(ch)
			delete(r.Resolver.MenuItemCreatedObservers, id)
		}
	}
	r.Resolver.mu.Unlock()

	return &model.MenuItemFull{
		ID:                 item.ID,
		Name:               item.Name,
		Description:        item.Description,
		Price:              item.Price,
		Category:           item.Category,
		Discount:           item.Discount,
		DiscountedPrice:    float64(discountedPrice),
		AvailabilityStatus: item.AvailabilityStatus,
		ImageURL:           item.ImageURL,
		CreatedAt:          item.CreatedAt,
		UpdatedAt:          item.UpdatedAt,
	}, nil
}

// UpdateMenuItem - Update an existing menu item
func (r *mutationResolver) UpdateMenuItem(ctx context.Context, id string, input model.UpdateMenuItem) (*model.MenuItemFull, error) {
	var discountedPrice float32
	if *input.Discount > 0 {
		resp, err := service.MenuClient.CalculateDiscount(ctx, &pb.DiscountRequest{Price: float32(*input.Price), Discount: float32(*input.Discount)})
		if err != nil {
			return nil, fmt.Errorf("failed to calculate discounted price: %v", err)

		}
		discountedPrice = resp.DiscountedPrice
	} else {
		discountedPrice = float32(*input.Price)
	}

	query := `UPDATE public.menu_list
	SET name = $1, description = $2, price = $3, category = $4, discount = $5,
	    discounted_price = $6, availability_status = $7, image_url = $8, updated_at = NOW()
	WHERE id = $9
	RETURNING id, name, description, price, discounted_price, category, discount, 
	          availability_status, image_url, created_at, updated_at`

	var item model.MenuItemFull
	err := r.Resolver.DB2.QueryRow(query,
		input.Name, input.Description, input.Price, input.Category,
		input.Discount, discountedPrice, input.AvailabilityStatus,
		input.ImageURL, id,
	).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price, &item.DiscountedPrice,
		&item.Category, &item.Discount, &item.AvailabilityStatus,
		&item.ImageURL, &item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return &model.MenuItemFull{
		ID:                 item.ID,
		Name:               item.Name,
		Description:        item.Description,
		Price:              item.Price,
		Category:           item.Category,
		Discount:           item.Discount,
		DiscountedPrice:    item.DiscountedPrice,
		AvailabilityStatus: item.AvailabilityStatus,
		ImageURL:           item.ImageURL,
		CreatedAt:          item.CreatedAt,
		UpdatedAt:          item.UpdatedAt,
	}, nil
}

// DeleteMenuItem is the resolver for the deleteMenuItem field.
func (r *mutationResolver) DeleteMenuItem(ctx context.Context, id string) (bool, error) {
	query := `DELETE FROM public.menu_list WHERE id = $1`
	_, err := r.Resolver.DB2.Exec(query, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// GetAllMenuItems - Fetch all menu items
func (r *queryResolver) GetAllMenuItems(ctx context.Context) ([]*model.MenuItemFull, error) {
	var discountedPrice float32
	query := `SELECT id, name, description, price, category, discount, discounted_price, availability_status, image_url, created_at, updated_at FROM public.menu_list`
	rows, err := r.Resolver.DB2.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var menuItems []*model.MenuItemFull
	for rows.Next() {
		var item model.MenuItemFull

		err := rows.Scan(
			&item.ID, &item.Name, &item.Description, &item.Price, &item.Category,
			&item.Discount, &discountedPrice, &item.AvailabilityStatus, &item.ImageURL,
			&item.CreatedAt, &item.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		item.DiscountedPrice = float64(discountedPrice)
		menuItems = append(menuItems, &item)
	}

	if err = rows.Err(); err != nil {
		return nil, err
	}

	var menuItemsFull []*model.MenuItemFull
	for _, item := range menuItems {
		menuItemsFull = append(menuItemsFull, &model.MenuItemFull{
			ID:                 item.ID,
			Name:               item.Name,
			Description:        item.Description,
			Price:              item.Price,
			Category:           item.Category,
			Discount:           item.Discount,
			DiscountedPrice:    item.DiscountedPrice,
			AvailabilityStatus: item.AvailabilityStatus,
			ImageURL:           item.ImageURL,
			CreatedAt:          item.CreatedAt,
			UpdatedAt:          item.UpdatedAt,
		})

	}
	return menuItemsFull, nil
}

// GetMenuItemByID is the resolver for the getMenuItemById field.
// GetMenuItemByID - Fetch a single menu item by ID
func (r *queryResolver) GetMenuItemByID(ctx context.Context, id string) (*model.MenuItemFull, error) {
	query := `SELECT id, name, description, price, category, discount, discounted_price, availability_status, image_url, created_at, updated_at 
	          FROM public.menu_list WHERE id = $1`

	var item model.MenuItem
	var discountedPrice float32
	err := r.Resolver.DB2.QueryRow(query, id).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price, &item.Category,
		&item.Discount, &discountedPrice, &item.AvailabilityStatus, &item.ImageURL,
		&item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return &model.MenuItemFull{
		ID:                 item.ID,
		Name:               item.Name,
		Description:        item.Description,
		Price:              item.Price,
		Category:           item.Category,
		Discount:           item.Discount,
		DiscountedPrice:    float64(discountedPrice),
		AvailabilityStatus: item.AvailabilityStatus,
		ImageURL:           item.ImageURL,
		CreatedAt:          item.CreatedAt,
		UpdatedAt:          item.UpdatedAt,
	}, nil
}

// GetMenuItemsByIds is the resolver for the getMenuItemsByIds field.
func (r *queryResolver) GetMenuItemsByIds(ctx context.Context, ids []string) ([]*model.MenuItemFull, error) {
	// Build the query with `IN` to fetch multiple items
	query := `SELECT id, name, description, price, category, discount, discounted_price, availability_status, image_url, created_at, updated_at
              FROM public.menu_list
              WHERE id = ANY($1::uuid[])`

	// Create a slice to hold the results
	var items []*model.MenuItemFull

	// Execute the query with the list of IDs
	rows, err := r.Resolver.DB2.Query(query, pq.Array(ids)) // Assuming you're using pq for UUID arrays
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// Loop through the results and map them to your model
	for rows.Next() {
		var item model.MenuItem
		var discountedPrice float32

		// Scan the row into the item struct
		err := rows.Scan(
			&item.ID, &item.Name, &item.Description, &item.Price, &item.Category,
			&item.Discount, &discountedPrice, &item.AvailabilityStatus, &item.ImageURL,
			&item.CreatedAt, &item.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}

		// Append the item to the results list
		items = append(items, &model.MenuItemFull{
			ID:                 item.ID,
			Name:               item.Name,
			Description:        item.Description,
			Price:              item.Price,
			Category:           item.Category,
			Discount:           item.Discount,
			DiscountedPrice:    float64(discountedPrice),
			AvailabilityStatus: item.AvailabilityStatus,
			ImageURL:           item.ImageURL,
			CreatedAt:          item.CreatedAt,
			UpdatedAt:          item.UpdatedAt,
		})
	}

	// Check for any errors during the iteration
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return items, nil
}

// MenuItemCreated is the resolver for the menuItemCreated field.
func (r *subscriptionResolver) MenuItemCreated(ctx context.Context) (<-chan *model.MenuItemFull, error) {
	id := uuid.New().String()
	ch := make(chan *model.MenuItemFull, 1)

	r.Resolver.mu.Lock()
	r.Resolver.MenuItemCreatedObservers[id] = ch
	r.Resolver.mu.Unlock()

	go func() {
		<-ctx.Done()
		r.Resolver.mu.Lock()
		delete(r.Resolver.MenuItemCreatedObservers, id)
		r.Resolver.mu.Unlock()
	}()

	return ch, nil
}
