package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"Graphql_Service/graph/model"
	"context"
)

// CreateMenuItem - Insert a new menu item
func (r *mutationResolver) CreateMenuItem(ctx context.Context, input model.NewMenuItem) (*model.MenuItemFull, error) {
	query := `INSERT INTO public.menu_list (name, description, price, category, discount, availability_status, image_url, created_at, updated_at)
	VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
	RETURNING id, name, description, price, category, discount, availability_status, image_url, created_at, updated_at`

	item := &model.MenuItem{
		Name:               input.Name,
		Description:        input.Description,
		Price:              input.Price,
		Category:           input.Category,
		Discount:           input.Discount,
		AvailabilityStatus: input.AvailabilityStatus,
		ImageURL:           input.ImageURL,
	}

	err := r.Resolver.DB2.QueryRow(query,
		item.Name, item.Description, item.Price, item.Category,
		item.Discount, item.AvailabilityStatus, item.ImageURL,
	).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price, &item.Category,
		&item.Discount, &item.AvailabilityStatus, &item.ImageURL,
		&item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	// resp, err := service.MenuClient.CalculateDiscountedPrice(ctx, &pb.DiscountedPriceRequest{Price: item.Price, Discount: item.Discount})
	// if err != nil {
	// 	return nil, fmt.Errorf("failed to calculate discounted price: %v", err)
	// }

	r.MenuItemCreated <- item

	return &model.MenuItemFull{
		ID:                 item.ID,
		Name:               item.Name,
		Description:        item.Description,
		Price:              item.Price,
		Category:           item.Category,
		Discount:           item.Discount,
		AvailabilityStatus: item.AvailabilityStatus,
		ImageURL:           item.ImageURL,
		CreatedAt:          item.CreatedAt,
		UpdatedAt:          item.UpdatedAt,
	}, nil
}

// UpdateMenuItem - Update an existing menu item
func (r *mutationResolver) UpdateMenuItem(ctx context.Context, id string, input model.UpdateMenuItem) (*model.MenuItemFull, error) {
	query := `UPDATE public.menu_list
	SET name = $1, description = $2, price = $3, category = $4, discount = $5,
	    availability_status = $6, image_url = $7, updated_at = NOW()
	WHERE id = $8
	RETURNING id, name, description, price, category, discount, availability_status, image_url, created_at, updated_at`

	var item model.MenuItem
	err := r.Resolver.DB2.QueryRow(query,
		input.Name, input.Description, input.Price, input.Category,
		input.Discount, input.AvailabilityStatus, input.ImageURL, id,
	).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price, &item.Category,
		&item.Discount, &item.AvailabilityStatus, &item.ImageURL,
		&item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return &model.MenuItemFull{
		ID:                 item.ID,
		Name:               item.Name,
		Description:        item.Description,
		Price:              item.Price,
		Category:           item.Category,
		Discount:           item.Discount,
		AvailabilityStatus: item.AvailabilityStatus,
		ImageURL:           item.ImageURL,
		CreatedAt:          item.CreatedAt,
		UpdatedAt:          item.UpdatedAt,
	}, nil
}

// DeleteMenuItem is the resolver for the deleteMenuItem field.
func (r *mutationResolver) DeleteMenuItem(ctx context.Context, id string) (bool, error) {
	query := `DELETE FROM public.menu_list WHERE id = $1`
	_, err := r.Resolver.DB2.Exec(query, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// GetAllMenuItems - Fetch all menu items
func (r *queryResolver) GetAllMenuItems(ctx context.Context) ([]*model.MenuItemFull, error) {
	query := `SELECT id, name, description, price, category, discount, availability_status, image_url, created_at, updated_at FROM public.menu_list`
	rows, err := r.Resolver.DB2.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var menuItems []*model.MenuItem
	for rows.Next() {
		var item model.MenuItem
		err := rows.Scan(
			&item.ID, &item.Name, &item.Description, &item.Price, &item.Category,
			&item.Discount, &item.AvailabilityStatus, &item.ImageURL,
			&item.CreatedAt, &item.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		menuItems = append(menuItems, &item)
	}

	if err = rows.Err(); err != nil {
		return nil, err
	}

	var menuItemsFull []*model.MenuItemFull
	for _, item := range menuItems {
		menuItemsFull = append(menuItemsFull, &model.MenuItemFull{
			ID:                 item.ID,
			Name:               item.Name,
			Description:        item.Description,
			Price:              item.Price,
			Category:           item.Category,
			Discount:           item.Discount,
			AvailabilityStatus: item.AvailabilityStatus,
			ImageURL:           item.ImageURL,
			CreatedAt:          item.CreatedAt,
			UpdatedAt:          item.UpdatedAt,
		})
	}
	return menuItemsFull, nil
}

// GetMenuItemByID is the resolver for the getMenuItemById field.
// GetMenuItemByID - Fetch a single menu item by ID
func (r *queryResolver) GetMenuItemByID(ctx context.Context, id string) (*model.MenuItemFull, error) {
	query := `SELECT id, name, description, price, category, discount, availability_status, image_url, created_at, updated_at 
	          FROM public.menu_list WHERE id = $1`

	var item model.MenuItem
	err := r.Resolver.DB2.QueryRow(query, id).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price, &item.Category,
		&item.Discount, &item.AvailabilityStatus, &item.ImageURL,
		&item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return &model.MenuItemFull{
		ID:                 item.ID,
		Name:               item.Name,
		Description:        item.Description,
		Price:              item.Price,
		Category:           item.Category,
		Discount:           item.Discount,
		AvailabilityStatus: item.AvailabilityStatus,
		ImageURL:           item.ImageURL,
		CreatedAt:          item.CreatedAt,
		UpdatedAt:          item.UpdatedAt,
	}, nil
}

// MenuItemCreated is the resolver for the menuItemCreated field.
func (r *subscriptionResolver) MenuItemCreated(ctx context.Context) (<-chan *model.MenuItem, error) {
	ch := make(chan *model.MenuItem)

	go func() {
		defer close(ch)
		for {
			select {
			case item := <-r.Resolver.MenuItemCreated:
				ch <- item
			case <-ctx.Done():
				return
			}
		}
	}()

	return ch, nil
}

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
