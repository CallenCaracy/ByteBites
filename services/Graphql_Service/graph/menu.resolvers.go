package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"Graphql_Service/graph/model"
	"context"
)

// CreateMenuItem - Insert a new menu item
func (r *mutationResolver) CreateMenuItem(ctx context.Context, input model.NewMenuItem) (*model.MenuItem, error) {
	query := `INSERT INTO public.menu_list (name, description, price, category, availability_status, image_url, created_at, updated_at)
	VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW()) RETURNING id, name, description, price, category, availability_status, image_url, created_at, updated_at`

	item := &model.MenuItem{
		Name:               input.Name,
		Description:        input.Description,
		Price:              input.Price,
		Category:           input.Category,
		AvailabilityStatus: input.AvailabilityStatus,
		ImageURL:           input.ImageURL,
	}

	err := r.Resolver.DB2.QueryRow(query,
		item.Name, item.Description, item.Price,
		item.Category, item.AvailabilityStatus, item.ImageURL,
	).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price,
		&item.Category, &item.AvailabilityStatus, &item.ImageURL,
		&item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return item, nil
}

// UpdateMenuItem - Update an existing menu item
func (r *mutationResolver) UpdateMenuItem(ctx context.Context, id string, input model.UpdateMenuItem) (*model.MenuItem, error) {
	query := `UPDATE public.menu_list SET name = $1, description = $2, price = $3, category = $4, availability_status = $5, image_url = $6, updated_at = NOW() WHERE id = $7 RETURNING id, name, description, price, category, availability_status, image_url, created_at, updated_at`

	var item model.MenuItem
	err := r.Resolver.DB2.QueryRow(query,
		input.Name, input.Description, input.Price, input.Category,
		input.AvailabilityStatus, input.ImageURL, id,
	).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price,
		&item.Category, &item.AvailabilityStatus, &item.ImageURL,
		&item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return &item, nil
}

// DeleteMenuItem is the resolver for the deleteMenuItem field.
func (r *mutationResolver) DeleteMenuItem(ctx context.Context, id string) (bool, error) {
	query := `DELETE FROM public.menu_list WHERE id = $1`
	_, err := r.Resolver.DB2.Exec(query, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// GetAllMenuItems - Fetch all menu items
func (r *queryResolver) GetAllMenuItems(ctx context.Context) ([]*model.MenuItem, error) {
	query := `SELECT id, name, description, price, category, availability_status, image_url, created_at, updated_at FROM public.menu_list`
	rows, err := r.Resolver.DB2.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var menuItems []*model.MenuItem
	for rows.Next() {
		var item model.MenuItem
		err := rows.Scan(
			&item.ID, &item.Name, &item.Description, &item.Price,
			&item.Category, &item.AvailabilityStatus, &item.ImageURL,
			&item.CreatedAt, &item.UpdatedAt,
		)
		if err != nil {
			return nil, err
		}
		menuItems = append(menuItems, &item)
	}

	if err = rows.Err(); err != nil {
		return nil, err
	}

	return menuItems, nil
}

// GetMenuItemByID is the resolver for the getMenuItemById field.
// GetMenuItemByID - Fetch a single menu item by ID
func (r *queryResolver) GetMenuItemByID(ctx context.Context, id string) (*model.MenuItem, error) {
	query := `SELECT id, name, description, price, category, availability_status, image_url, created_at, updated_at 
	          FROM public.menu_list WHERE id = $1`

	var item model.MenuItem
	err := r.Resolver.DB2.QueryRow(query, id).Scan(
		&item.ID, &item.Name, &item.Description, &item.Price,
		&item.Category, &item.AvailabilityStatus, &item.ImageURL,
		&item.CreatedAt, &item.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return &item, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
