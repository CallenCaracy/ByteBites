package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"Graphql_Service/graph/model"
	"context"
)

// CreateInventory is the resolver for the createInventory field.
func (r *mutationResolver) CreateInventory(ctx context.Context, menuID string, availableServings int32, lowStockThreshold *int32) (*model.Inventory, error) {
	query := `
        INSERT INTO public.menu_stock (menu_id, available_servings, low_stock_threshold, last_updated)
        VALUES ($1, $2, COALESCE($3, 5), NOW())
        RETURNING id, menu_id, available_servings, low_stock_threshold, last_updated
    `
	var inv model.Inventory
	err := r.Resolver.DB7.QueryRow(query, menuID, availableServings, lowStockThreshold).
		Scan(&inv.ID, &inv.MenuID, &inv.AvailableServings, &inv.LowStockThreshold, &inv.LastUpdated)
	if err != nil {
		return nil, err
	}
	return &inv, nil
}

// UpdateInventory is the resolver for the updateInventory field.
func (r *mutationResolver) UpdateInventory(ctx context.Context, id string, availableServings *int32, lowStockThreshold *int32) (*model.Inventory, error) {
	query := `
		UPDATE public.menu_stock
		SET 
			available_servings = COALESCE($2, available_servings),
			low_stock_threshold = COALESCE($3, low_stock_threshold),
			last_updated = NOW()
		WHERE menu_id = $1
		RETURNING id, menu_id, available_servings, low_stock_threshold, last_updated
	`

	var inv model.Inventory
	err := r.Resolver.DB7.QueryRow(query, id, availableServings, lowStockThreshold).
		Scan(&inv.ID, &inv.MenuID, &inv.AvailableServings, &inv.LowStockThreshold, &inv.LastUpdated)

	if err != nil {
		return nil, err
	}

	return &inv, nil
}

// DeleteInventory is the resolver for the deleteInventory field.
func (r *mutationResolver) DeleteInventory(ctx context.Context, id string) (bool, error) {
	query := `DELETE FROM public.menu_stock WHERE id = $1`
	_, err := r.Resolver.DB7.Exec(query, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateOrderQueue is the resolver for the createOrderQueue field.
func (r *mutationResolver) CreateOrderQueue(ctx context.Context, menuID string, orderID string, status *model.KitchenStatus) (*model.OrderQueue, error) {
	query := `
        INSERT INTO public.order_queue (menu_id, order_id, status, created_at)
        VALUES ($1, $2, COALESCE($3, 'preparing'), NOW())
        RETURNING id, menu_id, order_id, status, created_at
    `
	var order model.OrderQueue
	err := r.Resolver.DB7.QueryRow(query, menuID, orderID, status).
		Scan(&order.ID, &order.MenuID, &order.OrderID, &order.Status, &order.CreatedAt)
	if err != nil {
		return nil, err
	}
	return &order, nil
}

// UpdateOrderQueue is the resolver for the updateOrderQueue field.
func (r *mutationResolver) UpdateOrderQueue(ctx context.Context, id string, status *model.KitchenStatus) (*model.OrderQueue, error) {
	query := `
        UPDATE public.order_queue
        SET status = COALESCE($1, status),
            created_at = NOW()
        WHERE id = $2
        RETURNING id, menu_id, order_id, status, created_at
    `
	var order model.OrderQueue
	err := r.Resolver.DB7.QueryRow(query, status, id).
		Scan(&order.ID, &order.MenuID, &order.OrderID, &order.Status, &order.CreatedAt)
	if err != nil {
		return nil, err
	}
	return &order, nil
}

// DeleteOrderQueue is the resolver for the deleteOrderQueue field.
func (r *mutationResolver) DeleteOrderQueue(ctx context.Context, id string) (bool, error) {
	query := `DELETE FROM public.order_queue WHERE id = $1`
	_, err := r.Resolver.DB7.Exec(query, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// Inventories is the resolver for the inventories field.
func (r *queryResolver) Inventories(ctx context.Context) ([]*model.Inventory, error) {
	query := `SELECT id, menu_id, available_servings, low_stock_threshold, last_updated FROM public.menu_stock`
	rows, err := r.Resolver.DB7.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var inventories []*model.Inventory
	for rows.Next() {
		var inv model.Inventory
		err := rows.Scan(&inv.ID, &inv.MenuID, &inv.AvailableServings, &inv.LowStockThreshold, &inv.LastUpdated)
		if err != nil {
			return nil, err
		}
		inventories = append(inventories, &inv)
	}
	return inventories, nil
}

// Inventory is the resolver for the inventory field.
func (r *queryResolver) Inventory(ctx context.Context, id string) (*model.Inventory, error) {
	query := `SELECT id, menu_id, available_servings, low_stock_threshold, last_updated FROM public.menu_stock WHERE menu_id = $1`
	var inv model.Inventory
	err := r.Resolver.DB7.QueryRow(query, id).
		Scan(&inv.ID, &inv.MenuID, &inv.AvailableServings, &inv.LowStockThreshold, &inv.LastUpdated)
	if err != nil {
		return nil, err
	}
	return &inv, nil
}

// OrderQueues is the resolver for the orderQueues field.
func (r *queryResolver) OrderQueues(ctx context.Context) ([]*model.OrderQueue, error) {
	query := `SELECT id, menu_id, order_id, status, created_at FROM public.order_queue`
	rows, err := r.Resolver.DB7.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var orders []*model.OrderQueue
	for rows.Next() {
		var order model.OrderQueue
		err := rows.Scan(&order.ID, &order.MenuID, &order.OrderID, &order.Status, &order.CreatedAt)
		if err != nil {
			return nil, err
		}
		orders = append(orders, &order)
	}
	return orders, nil
}

// OrderQueue is the resolver for the orderQueue field.
func (r *queryResolver) OrderQueue(ctx context.Context, id string) (*model.OrderQueue, error) {
	query := `SELECT id, menu_id, order_id, status, created_at FROM public.order_queue WHERE id = $1`
	var order model.OrderQueue
	err := r.Resolver.DB7.QueryRow(query, id).
		Scan(&order.ID, &order.MenuID, &order.OrderID, &order.Status, &order.CreatedAt)
	if err != nil {
		return nil, err
	}
	return &order, nil
}
